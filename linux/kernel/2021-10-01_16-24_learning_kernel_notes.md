# What is linux kernel

It's just a program loaded on start time bu grub (which is the linux boot loader).
Grub feeds parameters to the kernel.

Note: On first run the memory space where the kernel will be loaded will be read only in order to check for integrity before the actual loading.

POSIX is the standard that all OS follow to define APIs that can be used by things like standard libraries to make system calls irrespective of the operating system. The intended consumers of POSIX are system and application developers.

## /proc /sys and device files

Virtual Filesystem are system that are not actually stored on disk.
The content of these folders are auto-generated by the kernel.
/proc and /sys are Virtual Filesystem

### /proc - shows what runs (which processes are currently running)

If /proc is not mounted then things wont work
ps command my not work if /proc is not mounted - why? because ps displays info about processes and /proc hold that info
Some /proc files are writable and whatever you do to the kernel it will have to done in /etc tunable files that will be read at start up.

On Linux every process will have at least one thread.
Use PTHREAD to create threads via C/C++.

Exmaple:
[root@localhost 32395]# cd fd
[root@localhost fd]# ls
0  1  2  255
[root@localhost fd]# ls -l
total 0
lrwx------ 1 root root 64 Oct  1 06:04 0 -> /dev/pts/6
lrwx------ 1 root root 64 Oct  1 07:06 1 -> /dev/pts/6
lrwx------ 1 root root 64 Oct  1 07:04 2 -> /dev/pts/6
lrwx------ 1 root root 64 Oct  1 07:06 255 -> /dev/pts/6

The entries above are file descriptors ()
0 = stdin
1 = stdout
2 = stderr
255 = can refer to a file or some place where we write

If we output for example "interrupts" we will see what happended to our devices.
The funny thing is that the interrupt file size will be 0, why?, because it's generate on demand

### /sys (shows what things are loaded in terms on external devices)

Also loaded at boot.
sysfs (sys file system) - stand for kernel object
Data structure in the kernel that is linked between the kernel and a hardware device

### Device files

Represent the drivers of your devices.
There a number of ways to identify device files like its version (c or b) - major numbers in conjunction with minor numbers

c - stands for character device function and will execute things like read(), write() and ioctl()
b -

[root@localhost proc]# cd /dev
[root@localhost dev]# ls -l /dev/null
crw-rw-rw- 1 root root 1, 3 Sep 17 05:20 /dev/null

c stands for character device with major 1 and minor 3 - so 1 and 3 devices will act like /dev/null

[root@localhost dev]# ls -l /dev/zero
crw-rw-rw- 1 root root 1, 5 Sep 17 05:20 /dev/zero

Similar to /dev/null, but the behavior will be determined by major 1 and minor 5.

## GRUB - boot loader

So GRUB is shell so you can interact with it
It is possible to interrupt a load command and then load a different linux kernel
man -k grub

/etc/default/grub - hold defaults for grub
/etc/grub.d - config file
40_custom would something we could change
run grub2-mkconfig to generate a new config file

## Loadable kernel modules

They can be found under /lib/modules
Each modules needs to have an unique name.
Modules should be build for the kernel you are using (basically when building a module you will load kernel libs so you need to use those to build - you probably have to rebuild your module if you switch kernels)

uname -r - gives you the kernel version - under this version you will find the modules

Find all modules in your kernel: find . -name '*.ko' | wc -l (counts the number of modules in your kernel)

### Commands that you use to work with LKM

ismod - lists all modules loaded (in order - the first one is the last one loaded)
    - the last number is the used by
    - the module can be used by another module

rmmod - will remove a module unless is in use
    - you can use -f to remove a module that the kernel still thinks it's in use (it may not be)

modinfo - will give info from the .ko file
    - module info
    - author
    - parameters
    - aliases
    - vermagic
    - more ..

depmod - is used to generate modules config files
dmesg - will give you details on the error that occurred when creating a module

modeprobe - loads a module and it's dependencies
    - you can use -r to remove a module and removes dependencies if they are not in use
    - insmod is not to be used

Note - modules can be part of the kernel image or they can be independent .ko files

modinfo cifs | grep -i description
    - cifs can be used to mount a windows folder into your linux system
    - find . -name cifs.ko (cifs.ko is a module)

### Compiling a module

make -C /lib/modules/$(uname -r)/build M=$PWD modules - this is the make command that uses the kernels make file
    - M is used by make to determine the directory where it will work
    - will have a mod.c file a makefile
      - the makefile will have one line: obj -m := mod.o
      - the mod.c -> gets compiled into the mod.o -> get compiled into the mod.ko

Code example for a module:
    #include <linux/inint.h>
    #include <linux/module.h>
    #include <linux/sched.h>

    int init_simple(void)
    {
        printk("some text");
        return 0;
    }

    void cleanup_simple(void)
    {
        printk("clean up");
    }

    module_init(init_simple); // register as init function
    module_exit(cleanup_simple); // register as exit function
    MODULE_LICENSE("GPL")

Steps to build a simple module:
    echo "obj -m := simplemodule.o" > Makefile
    make -C /lib/modules/$(uname -r)/build M=$PWD modules
    insmod ./simplemodule.ko // we can now load our module
    rmmod simplemodule // will attempt to remove the simple module if it's there
    dmesg | tail // get the last info messages - it's the message from the module_init or module_exit functions :) pretty cool

## Some useful commands un linux

Using ls variants for processor, plugged in devices and other
Examples:

- lshw, lspci, lsusb, lsbk, lscpu, lsdev
- man 2 read - will open up section 2 of the manual pages that will show you what the "read" system call will do
- dmesg - this will show you what the kernel logged with printk() function
  - dmesg | grep command - shows where the command text was found
  - dmesg | wc -l - counts lines
- journalctl - it's a command that can be used to display logs from processes/services and other such things (like your webserver process)
- tty shows the current file descriptor for what is opened (like the current shell)
- grep "define __NR" unistd.h | wc -l
- free - shows the current ram info
- head /proc/meminfo - shows similar things but in a nicer format
- when we want to create a shell script we have to write "#! /bin/bash" and then the script - cd "$@" - that changes dir to an input
- strace - will tell us the system calls made by a program
- when pipe-ing to "more" you can do /count to find something like count or :set number to display numbers of the lines
- use & to put a process in background (ex: sleep 100 &)
- ls -l | grep "^c" - list all files that have their line first char = "c"
    crw-rw-rw- 1 root root      1,   5 Sep 17 05:20 zero - in this case the first char is "c"

## Exercise

1. What kernel version is your Linux system running?
   > uname -vrs
   Linux localhost 3.10.51-1.el6.x86_64 #1 SMP Tue Aug 5 06:30:15 PDT 2014 x86_64 x86_64 x86_64 GNU/Linux
   Linux 3.10.51-1.el6.x86_64 #1 SMP Tue Aug 5 06:30:15 PDT 2014

2. What is the size of the kernel file that corresponds to the kernel your system is
running?
    > ls -l vmlinuz-3.10.51-1.el6.x86_64
    -rwxr-xr-x 1 root root 4835408 Aug  5  2014 vmlinuz-3.10.51-1.el6.x86_64

3. How much RAM is available to your running kernel? Note: It may or may not be
the amount of physical RAM on your system.
    > dmesg | grep Memory
    Memory: 4037692k/5242880k available (6120k kernel code, 1049096k absent, 156092k reserved, 5257k data, 1872k init)

4. The command strace will display the system calls that a process makes as it runs.
Using the man command, determine what option for strace will show a summary,
with a count, of the number of times a process called each system call. Using that
option, what system call is called the most by the command date
5. Can you determine, using strace , what system call is used to change the
directory?
6. By looking at inc lude/uapi/asm generic/unistd.h determine about how many
system calls are defined in your kernel source.
    cd /usr/src/kernels/3.10.51-1.el6.x86_64/include/uapi/asm-generic
    grep "define __NR" unistd.h | wc -l
    Answer is 347

7. Run a sleep 100 with & (to put it in the background). What files does its process
have open?
    ps -l to get it's proc number
    find the number under /proc and ls the files under fd folder

8. Does your system have a PCI Ethernet device?
   0b:00.0 Ethernet controller: VMware VMXNET3 Ethernet Controller (rev 01)

9. Is the kernel variable ip_forward (under /proc/sys/â€¦) set to 1 or 0 on your
system?
    it's set to 0

10. According to /sys/block , do you have a block device (disk) sda ? If so, do you
have device files for partitions of sda ? How many? Using strace , does the
command fdisk l (run it as root), open any files under /sys/dev/block
    Yes
    ls -l /dev/sda* - shows how many sda partitions we have
    strace fdisk -l |& grep sys/dev/block | grep open | wc -l - to get the number of things that were called with name opened

11. Using dmesg and grep , do you see the kernel reporting the kernel command line?
If not, can you determine if the boot messages from the kernel were lost? Does
your system have a log file that recorded the boot messages? You can grep for
BOOT_IMAGE under /var/log to look.
    dmesg | grep command

12. What other device files are character devices and share the same major number
with /dev/null
    ls -l | grep "^c" | grep " 1," - looking for files with their first char in line is "c" and has 1 as major version
